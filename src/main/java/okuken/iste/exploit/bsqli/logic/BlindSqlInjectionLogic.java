package okuken.iste.exploit.bsqli.logic;

import java.io.PrintStream;

import org.apache.commons.lang3.StringUtils;

import okuken.iste.consts.Captions;
import okuken.iste.exploit.bsqli.dto.BlindSqlInjectionConfigDto;
import okuken.iste.exploit.bsqli.dto.BlindSqlInjectionJudgeDto;
import okuken.iste.exploit.common.enums.SqlOperatorType;
import okuken.iste.util.BurpUtil;
import okuken.iste.util.ByteUtil;
import okuken.iste.util.CharUtil;
import okuken.iste.util.MessageUtil;
import okuken.iste.util.UiUtil;

public class BlindSqlInjectionLogic {

	public static final String POSITION_MARK_INDEX = "$ISTE:INDEX$";
	public static final String POSITION_MARK_OPERATOR_AND_VALUE = "$ISTE:OPEVAL$";
	public static final String POSITION_MARK_VALUE = "$ISTE:VAL$";

	private static final int RANGE_MIN_INCLUSIVE = 0x00;
	private static final int RANGE_MAX_INCLUSIVE = 0x7F;
	private static final int RANGE_MAX_EXCLUSIVE = 0x7F + 1;

	private volatile boolean attacking;
	private volatile boolean forceStop;

	private PrintStream logger;

	public BlindSqlInjectionLogic(PrintStream logger) {
		this.logger = logger;
	}

	public String startAttack(BlindSqlInjectionConfigDto dto) {

		if(!BurpUtil.isInScope(dto.getRequestTemplate(), dto.getHttpService())) {
			println("must select a request in scope (see: Target > Scope > Target Scope).");
			return null;
		}

		try {
			attacking = true;
			println("------------ Start (%s) ------------", UiUtil.now());
			println("(%s: %s)", Captions.TOOLS_EXPLOIT_BSQLI_JUDGEBY, dto.getJudgeCommand());

			var ret = attack(dto);

			println("Result:");
			println(ret);
			return ret;

		} catch(Exception e) {
			println(e);
			return null;
		} finally {
			attacking = false;
			println("------------  End  (%s) ------------", UiUtil.now());
		}
	}

	public void stopAttack() {
		forceStop = true;
	}

	public boolean isAttacking() {
		return attacking;
	}

	private String attack(BlindSqlInjectionConfigDto dto) throws InterruptedException {
		var ret = new StringBuilder();
		for(int i = dto.getStartIndex();; i++) {
			if(i > dto.getMaxIndex()) {
				println("finished according to max index setting.");
				break;
			}

			print("%d: ", i);
			var resultInt = attackImplBinarySearch(i, RANGE_MIN_INCLUSIVE, RANGE_MAX_EXCLUSIVE, dto);
			if(resultInt < 0) {
				println();
				println("failed");
				break;
			}

			var resultStr = CharUtil.getDisplayableRepresentation(resultInt);
			println();
			println(resultStr);

			if(resultInt == 0) { //NUL
				break;
			}

			ret.append(resultStr);
		}
		return ret.toString();
	}

	private int attackImplBinarySearch(int index, int low, int high, BlindSqlInjectionConfigDto dto) throws InterruptedException {
		if(dto.isUseOperatorAndValue()) {
			return attackImplBinarySearchByLessThan(index, RANGE_MIN_INCLUSIVE, RANGE_MAX_EXCLUSIVE, dto);
		}
		return attackImplBinarySearchByBetween(index, RANGE_MIN_INCLUSIVE, RANGE_MAX_INCLUSIVE, dto);
	}

	private int attackImplBinarySearchByLessThan(int index, int low, int high, BlindSqlInjectionConfigDto dto) throws InterruptedException {
		int mid = low + ((high - low) / 2);
		if(mid == low) {
			if(fetchAndJudge(index, SqlOperatorType.EQUALS, mid, dto)) {
				return mid;
			}
			return -1; //fail
		}

		if(fetchAndJudge(index, SqlOperatorType.LESS_THAN, mid, dto)) {
			return attackImplBinarySearchByLessThan(index, low, mid, dto);
		}
		return attackImplBinarySearchByLessThan(index, mid, high, dto);
	}

	private int attackImplBinarySearchByBetween(int index, int low, int high, BlindSqlInjectionConfigDto dto) throws InterruptedException {
		int mid = low + ((high - low) / 2);
		if(mid == low) {
			if(fetchAndJudge(index, null, low, dto)) {
				return low;
			}
			if(fetchAndJudge(index, null, low + 1, dto)) {
				return low + 1;
			}
			return -1; //fail
		}

		if(fetchAndJudge(index, null, mid, dto)) {
			return attackImplBinarySearchByBetween(index, low, mid, dto);
		}
		return attackImplBinarySearchByBetween(index, mid + 1, high, dto);
	}

	private boolean fetchAndJudge(int index, SqlOperatorType operator, int charInt, BlindSqlInjectionConfigDto dto) throws InterruptedException {
		checkForceStop();
		if(dto.getIntervalTimeMs() > 0) {
			Thread.sleep(dto.getIntervalTimeMs());
			checkForceStop();
		}

		var operatorStr = operator != null ? (dto.isNeedUrlEncode() ? operator.getUrlEncoded() : operator.getStr()) : "";
		var request = dto.getRequestTemplateStr()
				.replace(POSITION_MARK_INDEX, Integer.toString(index))
				.replace(POSITION_MARK_OPERATOR_AND_VALUE, operatorStr + Integer.toString(charInt))
				.replace(POSITION_MARK_VALUE, Integer.toString(charInt))
				.getBytes(ByteUtil.DEFAULT_SINGLE_BYTE_CHARSET);
		request = MessageUtil.updateContentLength(request);

		//TODO: impl useChain case

		var timerStart = System.currentTimeMillis();
		var response = BurpUtil.getCallbacks().makeHttpRequest(
				dto.getHttpService(),
				request);
		var time = System.currentTimeMillis() - timerStart;

		var ret = dto.getJudgeCommand().judge(new BlindSqlInjectionJudgeDto(response.getResponse(), (int)time));

		print("(%s%02x: %s) ", operator != null ? operator : "", charInt, ret);
		return ret;
	}

	private void checkForceStop() {
		if(forceStop) {
			forceStop = false;
			throw new RuntimeException("forced stop.");
		}
	}


	private void print(String message, Object... args) {
		logger.printf(message, args);
	}
	private void println(String message, Object... args) {
		logger.println(String.format(message, args));
	}
	private void println(Exception e) {
		if(StringUtils.isEmpty(e.getMessage())) {
			e.printStackTrace(logger);
			return;
		}
		println(e.getMessage());
	}
	private void println() {
		println("");
	}

}